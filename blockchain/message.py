"""
requestInfo(lastBlock, minstd, objetRequete, ipp, idM, ip, sign, clePublique):
d = dict :
- minstd :si numéro donné (1er ou nouveau)
        sinon le dernier écrit (si 0 en param) -> lastMinstd(lastBlock)
- message: encrypte ( objetRequete*DELIMITER*ipp*DELIMITER*idMedecin*DELIMITER*ipMedecin*DELIMITER*signatureMedecin )
            avec clePublique du receveur
return d


lastMinstd():
param: lastBlock
return lastBlock[data][Minstd]


sendInfo(lastBlock, minstd, cleSym, signSpe, clePubMed):
d = dict :
- minstd :si numéro donné (1er ou nouveau)
        sinon le dernier écrit (si 0 en param) -> lastMinstd(lastBlock)
- message : encrypte ( retour*DELIMITER*cleSymetrique*DELIMITER*signatureSpecialiste ) avec clePublique medecin envoyeur
return d
"""


from cryptographie.code.src.encryption import *


def request_info(lastBlock: object, minstd: int, requestObject: str, ipp: int, rpps:int, ip:str,
                signature: str, publicKey: str) -> dict:
    """
    Gives a dictionary with minstd and encrypted message

    :param lastBlock: last block of the given blockchain
    :param minstd: last minstd number generated
    :param requestObject: object of the request
    :param ipp: unique patient id (=identifiant permanent du patient)
    :param rpps: unique specialist id (= répertoire partagé des professionnels de santé)
    :param ip: ip address of the sender
    :param signature: signature of the sender
    :param publicKey: public key (generated by RSA) of the recipient
    :return: dictionary which serves as message through the blockchain transaction
    """

    if minstd == 0:
        minstd = last_minstd(lastBlock)

    data_str = f"{requestObject}*DELIMITER*{ipp}*DELIMITER*{rpps}*DELIMITER*{ip}*DELIMITER*{signature}"
    message = encrypte(data_str, publicKey)

    return {'minstd': minstd, 'message': message}


def last_minstd(lastBlock: object) -> object:
    pass

def encrypte(data, pubkey):
    pass


if __name__ == '__main__':

    doctorPublicKey, doctorPrivateKey = newKeyPair()
    specialistPublicKey, specialistPrivateKey = newKeyPair()


    # aller
    rpps = 48271
    ipp = 2147483647
    data = "DemandeAnalyseSanguine*DELIMITER*" + str(ipp) + "*DELIMITER*"+ str(rpps) + "*DELIMITER*192.168.0.22"

    signature = RSASignature(data, doctorPrivateKey)
    # toSendInBlockchainNotEncrypted = data.encode() + b"*SEPARATOR*" + signature
    # toSendInBlockchain = asymmetricRSAEncryption(toSendInBlockchainNotEncrypted, specialistPublicKey)
    toSendInBlockchain = asymmetricRSAEncryption(data.encode(), specialistPublicKey) + b"*SEPARATOR*" + signature
    print("Data not encrypted to send:\n", data, '\n')
    print("Data encrypted to send:\n", toSendInBlockchain,'\n')

    # retour
    receivedFromBlockchain = toSendInBlockchain
    dataReceived, signatureReceived = receivedFromBlockchain.split(b"*SEPARATOR*")
    dataReceived = asymmetricRSADecryption(dataReceived, specialistPrivateKey)
    dataReceived = dataReceived.decode()

    print("Data received:\n", dataReceived, '\n')
    print("None if valid signature:", verifyRSASignature(dataReceived, signatureReceived, doctorPublicKey))
    print("Data match ?", data == dataReceived)